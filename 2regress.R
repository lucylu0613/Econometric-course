# Last modified by Huei-Wen Teng on 2021/3/2

library(PoEdata)

data(food)
?food
head(food);		# print the first five rows
tail(food);       # print the last five rows

##
plot(food$income, food$food_exp, 
     ylim=c(0, max(food$food_exp)),
     xlim=c(0, max(food$income)),
     xlab="weekly income in $100", 
     ylab="weekly food expenditure in $", 
     type = "p")


# fit the model to the data
mod1 <- lm(food_exp ~ income, data = food)
b1 <- coef(mod1)[[1]]
b2 <- coef(mod1)[[2]]
smod1 <- summary(mod1)
smod1

abline(b1,b2)		# add the estimated (fitted) regression line

names(mod1)			# to see what's inside the object
names(smod1)

mod1$coefficients #coefficient­È
smod1$coefficients #coefficientsªí®æ
coef(mod1) #coefficient­È

# retrive the residuals and do a simple diagnostic test
r= resid(mod1)
plot(r)		         # scattor plot
hist(r)            # histogram 
plot(density(r))   # denisty plot
qqnorm(r)          # qqplot



# prediction
newx <- data.frame(income = c(20, 25, 27))
yhat <- predict(mod1, newx)
names(yhat) <- c("income=$2000", "$2500", "$2700") 
yhat  # prints the result


# # # Do a Simulation study to understand the 
# sampling properties of the estimators
# (1) draw the pdf of the independent variable 
# in the food expenditure model: 
# y = b1+b2 x + e (Here, only x is used from the food data 
# and assumed to be known  
# y is generated by the model)
N <- 40 
x1 <- 10
x2 <- 20
b1 <- 100
b2 <- 10
mu <- 0
sig2e <- 2500
sde <- sqrt(sig2e)
yhat1 <- b1+b2*x1
yhat2 <- b1+b2*x2
curve(dnorm(x, mean=yhat1, sd=sde), 0, 500, col="blue")
curve(dnorm(x, yhat2, sde), 0,500, add=TRUE, col="red")
abline(v=yhat1, col="blue", lty=2)
abline(v=yhat2, col="red", lty=2)
legend("topright", legend=c("f(y|x=10)", 
                            "f(y|x=20)"), lty=1,
       col=c("blue", "red"))

# (2) Calculate the theoretical distribution of b_2
x <- food$income
xbar <- mean(x)
sumx2 <- sum((x-xbar)^2)
varb2 <- sig2e/sumx2
sdb2 <- sqrt(varb2)
leftlim <- b2-3*sdb2
rightlim <- b2+3*sdb2
curve(dnorm(x, mean=b2, sd=sdb2), leftlim, rightlim)
abline(v=b2, lty=2)


# (3) Use x in the food dataset to generate price y. 
# Check b1hat, b2hat, and seb2hat
set.seed(12345)
y <- b1+b2*x+rnorm(N, mean=0, sd=sde)
plot(x, y)
mod6 <- lm(y~x)
b1hat <- coef(mod6)[[1]]
b2hat <- coef(mod6)[[2]]
mod6summary <- summary(mod6) #the summary contains the standard errors
seb2hat <- coef(mod6summary)[2,2]
b1hat
b2hat
seb2hat


# (4) Use x in the food dataset and implement a simluation study 
# to understand the sampling properties of b1, b2, and the erros. 
N <- 40
x <- food$income
nrsim <- 1000 #number of simulation
b1 <- 100
b2 <- 10
sde <- 50
vb2 <- numeric(nrsim) #stores the estimates of b2
for (i in 1:nrsim){
  set.seed(12345+10*i)
  y <- b1+b2*x+rnorm(N, mean=0, sd=sde)
  mod7 <- lm(y~x)
  vb2[i] <- coef(mod7)[[2]]
}
mb2 <- mean(vb2)
seb2 <- sd(vb2)

# (5) Summarize the results
plot(density(vb2))
curve(dnorm(x, b2, sdb2), col="red", add=TRUE)
abline(v = b2, col="red");
legend("topright", legend=c("true", "simulated"), 
       lty=1, col=c("black", "red")) # modified by Teng on 2021/3/9

 
hist(vb2, prob=TRUE, ylim=c(0,.4))
curve(dnorm(x, mean=b2, sd=sdb2), col="red", add=TRUE) # 


### Many applications require estimates of the variances and covariances of the regression coefficients. R stores them in the a matrix vcov():
varb1 <- vcov(mod1)[1, 1]
varb1
varb2 <- vcov(mod1)[2, 2]
varb2
covb1b2 <- vcov(mod1)[1,2]
covb1b2
vcov(mod1)

### Curve Models
### PRICE = beta1+ beta2*SQFT^2 + e
data(br) 
?br # show information of the dataset br  
plot(br$sqft, br$price, xlab="Total square feet", 
     ylab="Sale price, $", col="grey") # scattor plot

# PRICE = beta1+ beta2*SQFT^2 + e
mod3 <- lm(price~I(sqft^2), data=br)
summary(mod3)
b1 <- coef(mod3)[[1]]
b1
b2 <- coef(mod3)[[2]]
b2
sqftx=c(2000, 4000, 6000) #given values for sqft
pricex=b1+b2*sqftx^2 #prices corresponding to given sqft 
DpriceDsqft <- 2*b2*sqftx # marginal effect of sqft on price
DpriceDsqft
elasticity = DpriceDsqft*sqftx/pricex 
elasticity
curve(b1+b2*x^2, col="red", add=TRUE)   # add the quadratic curve to the scatter plot:

### The log-linear model
# log(SQFT) = beta1 + beta2 SQFT + e_i
data(br)
hist(br$price, col='grey')
hist(log(br$price), col='grey')
mod4 <- lm(log(price)~sqft, data=br)
mod4
ordat <- br[order(br$sqft), ] #order the dataset
mod4 <- lm(log(price)~sqft, data=ordat)
mod4
plot(br$sqft, br$price, col="grey")
lines(exp(fitted(mod4))~ordat$sqft, 
      col="blue", main="Log-linear Model")


### Using indicator variables in regression
data(utown)
?utown
price0bar <- mean(utown$price[which(utown$utown==0)])
price1bar <- mean(utown$price[which(utown$utown==1)])
price0bar		
price1bar
price1bar - price0bar # the average difference in house price if it is a university town house
mod5 <- lm(price~utown, data=utown)
b1 <- coef(mod5)[[1]] 
b2 <- coef(mod5)[[2]]
b1
b2
